{"version":3,"file":"ImplementsPlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/ImplementsPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ReflectionKind, DeclarationReflection, SignatureReflection } from '../../models/reflections/index';\r\nimport { Type, ReferenceType } from '../../models/types/index';\r\nimport { Component, ConverterComponent } from '../components';\r\nimport { Converter } from '../converter';\r\nimport { Context } from '../context';\r\n\r\n/**\r\n * A plugin that detects interface implementations of functions and\r\n * properties on classes and links them.\r\n */\r\n@Component({name: 'implements'})\r\nexport class ImplementsPlugin extends ConverterComponent {\r\n    /**\r\n     * Create a new ImplementsPlugin instance.\r\n     */\r\n    initialize() {\r\n        this.listenTo(this.owner, Converter.EVENT_RESOLVE, this.onResolve, -10);\r\n    }\r\n\r\n    /**\r\n     * Mark all members of the given class to be the implementation of the matching interface member.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param classReflection  The reflection of the classReflection class.\r\n     * @param interfaceReflection  The reflection of the interfaceReflection interface.\r\n     */\r\n    private analyzeClass(context: Context, classReflection: DeclarationReflection, interfaceReflection: DeclarationReflection) {\r\n        if (!interfaceReflection.children) {\r\n            return;\r\n        }\r\n\r\n        interfaceReflection.children.forEach((interfaceMember: DeclarationReflection) => {\r\n            if (!(interfaceMember instanceof DeclarationReflection)) {\r\n                return;\r\n            }\r\n\r\n            let classMember: DeclarationReflection;\r\n\r\n            if (!classReflection.children) {\r\n                return;\r\n            }\r\n\r\n            for (let index = 0, count = classReflection.children.length; index < count; index++) {\r\n                const child = classReflection.children[index];\r\n                if (child.name !== interfaceMember.name) {\r\n                    continue;\r\n                }\r\n                if (child.flags.isStatic !== interfaceMember.flags.isStatic) {\r\n                    continue;\r\n                }\r\n\r\n                classMember = child;\r\n                break;\r\n            }\r\n\r\n            if (!classMember) {\r\n                return;\r\n            }\r\n\r\n            const interfaceMemberName = interfaceReflection.name + '.' + interfaceMember.name;\r\n            classMember.implementationOf = new ReferenceType(interfaceMemberName, ReferenceType.SYMBOL_ID_RESOLVED, interfaceMember);\r\n            this.copyComment(classMember, interfaceMember);\r\n\r\n            if (interfaceMember.kindOf(ReflectionKind.FunctionOrMethod) && interfaceMember.signatures && classMember.signatures) {\r\n                interfaceMember.signatures.forEach((interfaceSignature: SignatureReflection) => {\r\n                    const interfaceParameters = interfaceSignature.getParameterTypes();\r\n                    classMember.signatures.forEach((classSignature: SignatureReflection) => {\r\n                        if (Type.isTypeListEqual(interfaceParameters, classSignature.getParameterTypes())) {\r\n                            classSignature.implementationOf = new ReferenceType(interfaceMemberName, ReferenceType.SYMBOL_ID_RESOLVED, interfaceSignature);\r\n                            this.copyComment(classSignature, interfaceSignature);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Copy the comment of the source reflection to the target reflection.\r\n     *\r\n     * @param target\r\n     * @param source\r\n     */\r\n    private copyComment(target: Reflection, source: Reflection) {\r\n        if (target.comment && source.comment && target.comment.hasTag('inheritdoc')) {\r\n            target.comment.copyFrom(source.comment);\r\n\r\n            if (target instanceof SignatureReflection && target.parameters &&\r\n                source instanceof SignatureReflection && source.parameters) {\r\n                for (let index = 0, count = target.parameters.length; index < count; index++) {\r\n                    if (target.parameters[index].comment) {\r\n                        target.parameters[index].comment.copyFrom(source.parameters[index].comment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Triggered when the converter resolves a reflection.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param reflection  The reflection that is currently resolved.\r\n     */\r\n    private onResolve(context: Context, reflection: DeclarationReflection) {\r\n        if (reflection.kindOf(ReflectionKind.Class) && reflection.implementedTypes) {\r\n            reflection.implementedTypes.forEach((type: Type) => {\r\n                if (!(type instanceof ReferenceType)) {\r\n                    return;\r\n                }\r\n\r\n                const source = <DeclarationReflection> (<ReferenceType> type).reflection;\r\n                if (source && source.kindOf(ReflectionKind.Interface)) {\r\n                    this.analyzeClass(context, reflection, source);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n"]}