{"version":3,"file":"TypePlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/TypePlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ReflectionKind, Decorator, DeclarationReflection, DeclarationHierarchy } from '../../models/reflections/index';\r\nimport { Type, ReferenceType, TupleType, UnionType, IntersectionType, ArrayType } from '../../models/types/index';\r\nimport { Component, ConverterComponent } from '../components';\r\nimport { Converter } from '../converter';\r\nimport { Context } from '../context';\r\n\r\n/**\r\n * A handler that converts all instances of [[LateResolvingType]] to their renderable equivalents.\r\n */\r\n@Component({name: 'type'})\r\nexport class TypePlugin extends ConverterComponent {\r\n    reflections: DeclarationReflection[] = [];\r\n\r\n    /**\r\n     * Create a new TypeHandler instance.\r\n     */\r\n    initialize() {\r\n        this.listenTo(this.owner, {\r\n            [Converter.EVENT_RESOLVE]:     this.onResolve,\r\n            [Converter.EVENT_RESOLVE_END]: this.onResolveEnd\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggered when the converter resolves a reflection.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param reflection  The reflection that is currently resolved.\r\n     */\r\n    private onResolve(context: Context, reflection: DeclarationReflection) {\r\n        const project = context.project;\r\n\r\n        resolveType(reflection, <ReferenceType> reflection.type);\r\n        resolveType(reflection, <ReferenceType> reflection.inheritedFrom);\r\n        resolveType(reflection, <ReferenceType> reflection.overwrites);\r\n        resolveTypes(reflection, reflection.extendedTypes);\r\n        resolveTypes(reflection, reflection.extendedBy);\r\n        resolveTypes(reflection, reflection.implementedTypes);\r\n\r\n        if (reflection.decorators) {\r\n            reflection.decorators.forEach((decorator: Decorator) => {\r\n                if (decorator.type) {\r\n                    resolveType(reflection, decorator.type);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (reflection.kindOf(ReflectionKind.ClassOrInterface)) {\r\n            this.postpone(reflection);\r\n\r\n            walk(reflection.implementedTypes, (target) => {\r\n                this.postpone(target);\r\n                if (!target.implementedBy) {\r\n                    target.implementedBy = [];\r\n                }\r\n                target.implementedBy.push(new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection));\r\n            });\r\n\r\n            walk(reflection.extendedTypes, (target) => {\r\n                this.postpone(target);\r\n                if (!target.extendedBy) {\r\n                    target.extendedBy = [];\r\n                }\r\n                target.extendedBy.push(new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection));\r\n            });\r\n        }\r\n\r\n        function walk(types: Type[], callback: {(declaration: DeclarationReflection): void}) {\r\n            if (!types) {\r\n                return;\r\n            }\r\n            types.forEach((type: ReferenceType) => {\r\n                if (!(type instanceof ReferenceType)) {\r\n                    return;\r\n                }\r\n                if (!type.reflection || !(type.reflection instanceof DeclarationReflection)) {\r\n                    return;\r\n                }\r\n                callback(<DeclarationReflection> type.reflection);\r\n            });\r\n        }\r\n\r\n        function resolveTypes(reflection: Reflection, types: Type[]) {\r\n            if (!types) {\r\n                return;\r\n            }\r\n            for (let i = 0, c = types.length; i < c; i++) {\r\n                resolveType(reflection, <ReferenceType> types[i]);\r\n            }\r\n        }\r\n\r\n        function resolveType(reflection: Reflection, type: Type) {\r\n            if (type instanceof ReferenceType) {\r\n                const referenceType: ReferenceType = <ReferenceType> type;\r\n                if (referenceType.symbolID === ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME) {\r\n                    referenceType.reflection = reflection.findReflectionByName(referenceType.name);\r\n                } else if (!referenceType.reflection && referenceType.symbolID !== ReferenceType.SYMBOL_ID_RESOLVED) {\r\n                    referenceType.reflection = project.reflections[project.symbolMapping[referenceType.symbolID]];\r\n                }\r\n\r\n                if (referenceType.typeArguments) {\r\n                    referenceType.typeArguments.forEach((typeArgument: Type) => {\r\n                        resolveType(reflection, typeArgument);\r\n                    });\r\n                }\r\n            } else if (type instanceof TupleType) {\r\n                const tupleType: TupleType = <TupleType> type;\r\n                for (let index = 0, count = tupleType.elements.length; index < count; index++) {\r\n                    resolveType(reflection, tupleType.elements[index]);\r\n                }\r\n            } else if (type instanceof UnionType || type instanceof IntersectionType) {\r\n                const unionOrIntersectionType: UnionType | IntersectionType = <UnionType | IntersectionType> type;\r\n                for (let index = 0, count = unionOrIntersectionType.types.length; index < count; index++) {\r\n                    resolveType(reflection, unionOrIntersectionType.types[index]);\r\n                }\r\n            } else if (type instanceof ArrayType) {\r\n                resolveType(reflection, type.elementType);\r\n            }\r\n        }\r\n    }\r\n\r\n    private postpone(reflection: DeclarationReflection) {\r\n        if (this.reflections.indexOf(reflection) === -1) {\r\n            this.reflections.push(reflection);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Triggered when the converter has finished resolving a project.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     */\r\n    private onResolveEnd(context: Context) {\r\n        this.reflections.forEach((reflection) => {\r\n            if (reflection.implementedBy) {\r\n                reflection.implementedBy.sort((a: Type, b: Type): number => {\r\n                    if (a['name'] === b['name']) {\r\n                        return 0;\r\n                    }\r\n                    return a['name'] > b['name'] ? 1 : -1;\r\n                });\r\n            }\r\n\r\n            let root: DeclarationHierarchy;\r\n            let hierarchy: DeclarationHierarchy;\r\n            function push(types: Type[]) {\r\n                const level: DeclarationHierarchy = {types: types};\r\n                if (hierarchy) {\r\n                    hierarchy.next = level;\r\n                    hierarchy = level;\r\n                } else {\r\n                    root = hierarchy = level;\r\n                }\r\n            }\r\n\r\n            if (reflection.extendedTypes) {\r\n                push(reflection.extendedTypes);\r\n            }\r\n\r\n            push([new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection)]);\r\n            hierarchy.isTarget = true;\r\n\r\n            if (reflection.extendedBy) {\r\n                push(reflection.extendedBy);\r\n            }\r\n\r\n            reflection.typeHierarchy = root;\r\n        });\r\n    }\r\n}\r\n"]}