{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/signature.ts"],"names":[],"mappings":";;AAAA,+BAAiC;AAEjC,4CAA2H;AAE3H,0CAAyC;AACzC,yCAA8C;AAC9C,yCAAkD;AAWlD,yBAAgC,OAAgB,EAAE,IAA6B,EAAE,IAAY,EAAE,IAAoB;IAC/G,IAAM,SAAS,GAA2B,OAAO,CAAC,KAAK,CAAC;IACxD,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,YAAY,2BAAmB,CAAC,CAAC,CAAC,CAAC;QAC9C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAED,IAAM,SAAS,GAAG,IAAI,2BAAmB,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IACjE,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE;QACpD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,SAAkC;YACvD,2BAAe,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC,IAAI,GAAG,oBAAoB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAErD,EAAE,CAAC,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;YAC1B,SAAS,CAAC,aAAa,GAAG,+BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC9E,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,sBAAsB,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACnE,MAAM,CAAC,SAAS,CAAC;AACrB,CAAC;AAtBD,0CAsBC;AASD,8BAA8B,OAAgB,EAAE,IAA6B;IACzE,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC;QACtF,IAAI,CAAC;YACD,IAAM,SAAS,GAAG,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;YAC5D,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1G,CAAC;QAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA,CAAC;IACtB,CAAC;IAED,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACZ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7D,CAAC;IAAC,IAAI,CAAC,CAAC;QACJ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACxD,CAAC;AACL,CAAC","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { ReflectionKind, SignatureReflection, ContainerReflection, DeclarationReflection, Type } from '../../models/index';\r\nimport { Context } from '../context';\r\nimport { Converter } from '../converter';\r\nimport { createParameter } from './parameter';\r\nimport { createReferenceType } from './reference';\r\n\r\n/**\r\n * Create a new signature reflection from the given node.\r\n *\r\n * @param context  The context object describing the current state the converter is in.\r\n * @param node  The TypeScript node containing the signature declaration that should be reflected.\r\n * @param name  The name of the function or method this signature belongs to.\r\n * @param kind  The desired kind of the reflection.\r\n * @returns The newly created signature reflection describing the given node.\r\n */\r\nexport function createSignature(context: Context, node: ts.SignatureDeclaration, name: string, kind: ReflectionKind): SignatureReflection {\r\n    const container = <DeclarationReflection> context.scope;\r\n    if (!(container instanceof ContainerReflection)) {\r\n        throw new Error('Expected container reflection.');\r\n    }\r\n\r\n    const signature = new SignatureReflection(container, name, kind);\r\n    context.registerReflection(signature, node);\r\n    context.withScope(signature, node.typeParameters, true, () => {\r\n        node.parameters.forEach((parameter: ts.ParameterDeclaration) => {\r\n            createParameter(context, parameter);\r\n        });\r\n\r\n        signature.type = extractSignatureType(context, node);\r\n\r\n        if (container.inheritedFrom) {\r\n            signature.inheritedFrom = createReferenceType(context, node.symbol, true);\r\n        }\r\n    });\r\n\r\n    context.trigger(Converter.EVENT_CREATE_SIGNATURE, signature, node);\r\n    return signature;\r\n}\r\n\r\n/**\r\n * Extract the return type of the given signature declaration.\r\n *\r\n * @param context  The context object describing the current state the converter is in.\r\n * @param node  The signature declaration whose return type should be determined.\r\n * @returns The return type reflection of the given signature.\r\n */\r\nfunction extractSignatureType(context: Context, node: ts.SignatureDeclaration): Type {\r\n    const checker = context.checker;\r\n    if (node.kind & ts.SyntaxKind.CallSignature || node.kind & ts.SyntaxKind.CallExpression) {\r\n        try {\r\n            const signature = checker.getSignatureFromDeclaration(node);\r\n            return context.converter.convertType(context, node.type, checker.getReturnTypeOfSignature(signature));\r\n        } catch (error) {}\r\n    }\r\n\r\n    if (node.type) {\r\n        return context.converter.convertType(context, node.type);\r\n    } else {\r\n        return context.converter.convertType(context, node);\r\n    }\r\n}\r\n"]}