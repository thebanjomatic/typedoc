{"version":3,"file":"constructor.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/constructor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { Reflection, ReflectionKind, ReflectionFlag, ReferenceType, Comment } from '../../models/index';\r\nimport { createDeclaration, createSignature, createComment } from '../factories/index';\r\nimport { Context } from '../context';\r\nimport { Converter } from '../converter';\r\nimport { Component, ConverterNodeComponent } from '../components';\r\n\r\n@Component({name: 'node:constructor'})\r\nexport class ConstructorConverter extends ConverterNodeComponent<ts.ConstructorDeclaration> {\r\n    /**\r\n     * List of supported TypeScript syntax kinds.\r\n     */\r\n    supports: ts.SyntaxKind[] = [\r\n        ts.SyntaxKind.Constructor,\r\n        ts.SyntaxKind.ConstructSignature\r\n    ];\r\n\r\n    /**\r\n     * Analyze the given constructor declaration node and create a suitable reflection.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node     The constructor declaration node that should be analyzed.\r\n     * @return The resulting reflection or NULL.\r\n     */\r\n    convert(context: Context, node: ts.ConstructorDeclaration): Reflection {\r\n        const parent = context.scope;\r\n        const hasBody = !!node.body;\r\n        const method = createDeclaration(context, node, ReflectionKind.Constructor, 'constructor');\r\n\r\n        if (node.parameters && node.parameters.length) {\r\n            const comment = method ? method.comment : createComment(node);\r\n            for (let parameter of node.parameters) {\r\n                this.addParameterProperty(context, parameter, comment);\r\n            }\r\n        }\r\n\r\n        context.withScope(method, () => {\r\n            if (!hasBody || !method.signatures) {\r\n                const name = 'new ' + parent.name;\r\n                const signature = createSignature(context, node, name, ReflectionKind.ConstructorSignature);\r\n                // If no return type defined, use the parent one.\r\n                if (!node.type) {\r\n                    signature.type = new ReferenceType(parent.name, ReferenceType.SYMBOL_ID_RESOLVED, parent);\r\n                }\r\n                method.signatures = method.signatures || [];\r\n                method.signatures.push(signature);\r\n            } else {\r\n                context.trigger(Converter.EVENT_FUNCTION_IMPLEMENTATION, method, node);\r\n            }\r\n        });\r\n\r\n        return method;\r\n    }\r\n\r\n    /**\r\n     * Analyze parameters in given constructor declaration node and create a suitable reflection.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node     The constructor declaration node that should be analyzed.\r\n     * @return The resulting reflection or NULL.\r\n     */\r\n    private addParameterProperty(context: Context, parameter: ts.ParameterDeclaration, comment: Comment) {\r\n        const modifiers = ts.getCombinedModifierFlags(parameter);\r\n        const visibility = modifiers & (ts.ModifierFlags.Public | ts.ModifierFlags.Protected |\r\n                                        ts.ModifierFlags.Private | ts.ModifierFlags.Readonly);\r\n        if (!visibility) {\r\n            return;\r\n        }\r\n\r\n        const privateParameter = modifiers & ts.ModifierFlags.Private;\r\n        if (privateParameter && context.converter.excludePrivate) {\r\n            return;\r\n        }\r\n\r\n        const property = createDeclaration(context, parameter, ReflectionKind.Property);\r\n        if (!property) {\r\n            return;\r\n        }\r\n\r\n        property.setFlag(ReflectionFlag.Static, false);\r\n        property.type = this.owner.convertType(context, parameter.type, context.getTypeAtLocation(parameter));\r\n\r\n        if (comment) {\r\n            const tag = comment.getTag('param', property.name);\r\n            if (tag && tag.text) {\r\n                property.comment = new Comment(tag.text);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}