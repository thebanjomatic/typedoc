{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/reference.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,+BAAiC;AAEjC,kDAA+E;AAC/E,wDAAuF;AACvF,4CAAyD;AACzD,4CAAqF;AAErF,0CAAyC;AAGzC;IAAwC,sCAAsB;IAD9D;QAAA,qEAkIC;QA5HG,cAAQ,GAAG,CAAC,EAAE,CAAC;;IA4HnB,CAAC;IAvHG,yCAAY,GAAZ,UAAa,OAAgB,EAAE,IAA0B,EAAE,IAAsB;QAC7E,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAChD,CAAC;IAKD,yCAAY,GAAZ,UAAa,OAAgB,EAAE,IAAsB;QACjD,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAChD,CAAC;IAiBD,wCAAW,GAAX,UAAY,OAAgB,EAAE,IAA0B,EAAE,IAAsB;QAAhF,iBAaC;QAZG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,OAAO,IAAI,qBAAa,CAAC,QAAQ,CAAC,CAAC;SACtC;aAAM,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,WAAW,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,aAAa,CAAC,EAAE;YACzI,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC1D;QAED,IAAM,MAAM,GAAG,2BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACzD,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC,EAAlC,CAAkC,CAAC,CAAC;SAC5F;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAgBD,wCAAW,GAAX,UAAY,OAAgB,EAAE,IAAsB;QAApD,iBAaC;QAZG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,OAAO,IAAI,qBAAa,CAAC,QAAQ,CAAC,CAAC;SACtC;aAAM,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,WAAW,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,aAAa,CAAC,EAAE;YACzI,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;SACpD;QAED,IAAM,MAAM,GAAG,2BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACzD,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,EAAxC,CAAwC,CAAC,CAAC;SAClG;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAwBO,2CAAc,GAAtB,UAAuB,OAAgB,EAAE,MAAiB,EAAE,IAAc;QAA1E,iBA0BC;QAzBG,KAAwB,UAAmB,EAAnB,KAAA,MAAM,CAAC,YAAY,EAAnB,cAAmB,EAAnB,IAAmB,EAAE;YAAxC,IAAI,aAAW,SAAA;YAChB,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,aAAW,CAAC,KAAK,CAAC,CAAC,EAAE;gBAChD,IAAI,aAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW;oBAC1C,aAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,uBAAuB,EAAE;oBAChE,OAAO,2BAAmB,CAAC,OAAO,EAAE,aAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;iBAClE;qBAAM;oBACH,OAAO,2BAAmB,CAAC,OAAO,EAAE,aAAW,CAAC,MAAM,CAAC,CAAC;iBAC3D;aACJ;SACJ;QAED,IAAM,WAAW,GAAG,IAAI,6BAAqB,EAAE,CAAC;QAChD,WAAW,CAAC,IAAI,GAAG,sBAAc,CAAC,WAAW,CAAC;QAC9C,WAAW,CAAC,IAAI,GAAG,QAAQ,CAAC;QAC5B,WAAW,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC;QAEnC,OAAO,CAAC,kBAAkB,CAAC,WAAW,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QACtD,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,wBAAwB,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;QACvE,OAAO,CAAC,SAAS,CAAC,WAAW,EAAE;YAC3B,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,IAAI;gBAC7B,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;YAC1C,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,sBAAc,CAAC,WAAW,CAAC,CAAC;IAC3C,CAAC;IAhIQ,kBAAkB;QAD9B,sBAAS,CAAC,EAAC,IAAI,EAAE,gBAAgB,EAAC,CAAC;OACvB,kBAAkB,CAiI9B;IAAD,yBAAC;CAAA,AAjID,CAAwC,mCAAsB,GAiI7D;AAjIY,gDAAkB","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { Type, IntrinsicType, ReflectionType } from '../../models/types/index';\r\nimport { ReflectionKind, DeclarationReflection } from '../../models/reflections/index';\r\nimport { createReferenceType } from '../factories/index';\r\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\r\nimport { Context } from '../context';\r\nimport { Converter } from '../converter';\r\n\r\n@Component({name: 'type:reference'})\r\nexport class ReferenceConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.TypeReference, ts.TypeReferenceNode> {\r\n    /**\r\n     * The priority this converter should be executed with.\r\n     * A higher priority means the converter will be applied earlier.\r\n     */\r\n    priority = -50;\r\n\r\n    /**\r\n     * Test whether this converter can handle the given TypeScript node.\r\n     */\r\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): boolean {\r\n        return !!(type.flags & ts.TypeFlags.Object);\r\n    }\r\n\r\n    /**\r\n     * Test whether this converter can handle the given TypeScript type.\r\n     */\r\n    supportsType(context: Context, type: ts.TypeReference): boolean {\r\n        return !!(type.flags & ts.TypeFlags.Object);\r\n    }\r\n\r\n    /**\r\n     * Convert the type reference node to its type reflection.\r\n     *\r\n     * This is a node based converter, see [[convertTypeReferenceType]] for the type equivalent.\r\n     *\r\n     * ```\r\n     * class SomeClass { }\r\n     * let someValue: SomeClass;\r\n     * ```\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node  The type reference node that should be converted.\r\n     * @param type  The type of the type reference node.\r\n     * @returns The type reflection representing the given reference node.\r\n     */\r\n    convertNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): Type {\r\n        if (!type.symbol) {\r\n            return new IntrinsicType('Object');\r\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\r\n            return this.convertLiteral(context, type.symbol, node);\r\n        }\r\n\r\n        const result = createReferenceType(context, type.symbol);\r\n        if (node.typeArguments) {\r\n            result.typeArguments = node.typeArguments.map((n) => this.owner.convertType(context, n));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert the given type reference to its type reflection.\r\n     *\r\n     * This is a type based converter, see [[convertTypeReference]] for the node equivalent.\r\n     *\r\n     * ```\r\n     * class SomeClass { }\r\n     * let someValue: SomeClass;\r\n     * ```\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param type  The type reference that should be converted.\r\n     * @returns The type reflection representing the given type reference.\r\n     */\r\n    convertType(context: Context, type: ts.TypeReference): Type {\r\n        if (!type.symbol) {\r\n            return new IntrinsicType('Object');\r\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\r\n            return this.convertLiteral(context, type.symbol);\r\n        }\r\n\r\n        const result = createReferenceType(context, type.symbol);\r\n        if (type.typeArguments) {\r\n            result.typeArguments = type.typeArguments.map((t) => this.owner.convertType(context, null, t));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a type literal reflection.\r\n     *\r\n     * This is a utility function used by [[convertTypeReferenceNode]] and\r\n     * [[convertTypeReferenceType]] when encountering an object or type literal.\r\n     *\r\n     * A type literal is explicitly set:\r\n     * ```\r\n     * let someValue: {a: string; b: number;};\r\n     * ```\r\n     *\r\n     * An object literal types are usually reflected by the TypeScript compiler:\r\n     * ```\r\n     * function someFunction() { return {a: 'Test', b: 1024}; }\r\n     * ```\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param symbol  The symbol describing the type literal.\r\n     * @param node  If known the node which produced the type literal. Type literals that are\r\n     *   implicitly generated by TypeScript won't have a corresponding node.\r\n     * @returns A type reflection representing the given type literal.\r\n     */\r\n    private convertLiteral(context: Context, symbol: ts.Symbol, node?: ts.Node): Type {\r\n        for (let declaration of symbol.declarations) {\r\n            if (context.visitStack.indexOf(declaration) !== -1) {\r\n                if (declaration.kind === ts.SyntaxKind.TypeLiteral ||\r\n                        declaration.kind === ts.SyntaxKind.ObjectLiteralExpression) {\r\n                    return createReferenceType(context, declaration.parent.symbol);\r\n                } else {\r\n                    return createReferenceType(context, declaration.symbol);\r\n                }\r\n            }\r\n        }\r\n\r\n        const declaration = new DeclarationReflection();\r\n        declaration.kind = ReflectionKind.TypeLiteral;\r\n        declaration.name = '__type';\r\n        declaration.parent = context.scope;\r\n\r\n        context.registerReflection(declaration, null, symbol);\r\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, declaration, node);\r\n        context.withScope(declaration, () => {\r\n            symbol.declarations.forEach((node) => {\r\n                this.owner.convertNode(context, node);\r\n            });\r\n        });\r\n\r\n        return new ReflectionType(declaration);\r\n    }\r\n}\r\n"]}