{"version":3,"file":"alias.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/alias.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AACA,uCAAyC;AAEzC,4CAAmD;AACnD,4CAAqF;AAIrF;IAAoC,kCAAsB;IAD1D;QAAA,qEA2EC;QArEG,cAAQ,GAAG,GAAG,CAAC;;IAqEnB,CAAC;IAvDG,qCAAY,GAAZ,UAAa,OAAgB,EAAE,IAA0B,EAAE,IAAa;QACpE,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YACnC,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;QAChC,IAAI,UAAU,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;YACrC,UAAU,CAAC,KAAK,EAAE,CAAC;QACvB,CAAC;QAED,IAAI,QAAQ,GAAG,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC3D,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YACnB,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QAED,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC1D,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QACvC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QAEnC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACvD,CAAC;IAkBD,oCAAW,GAAX,UAAY,OAAgB,EAAE,IAA0B;QAAxD,iBASC;QARG,IAAM,IAAI,GAAG,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAM,MAAM,GAAG,IAAI,qBAAa,CAAC,IAAI,EAAE,qBAAa,CAAC,yBAAyB,CAAC,CAAC;QAEhF,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC,EAAlC,CAAkC,CAAC,CAAC;QAC3F,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAzEQ,cAAc;QAD1B,sBAAS,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC;OACnB,cAAc,CA0E1B;IAAD,qBAAC;CAAA,AA1ED,CAAoC,mCAAsB,GA0EzD;AA1EY,wCAAc","sourcesContent":["import * as ts from 'typescript';\r\nimport * as _ts from '../../ts-internal';\r\n\r\nimport { ReferenceType } from '../../models/index';\r\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\r\nimport { Context } from '../context';\r\n\r\n@Component({name: 'type:alias'})\r\nexport class AliasConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.Type, ts.TypeReferenceNode> {\r\n    /**\r\n     * The priority this converter should be executed with.\r\n     * A higher priority means the converter will be applied earlier.\r\n     */\r\n    priority = 100;\r\n\r\n    /**\r\n     * Test whether the given node and type definitions represent a type alias.\r\n     *\r\n     * The compiler resolves type aliases pretty early and there is no field telling us\r\n     * whether the given node was a type alias or not. So we have to compare the type name of the\r\n     * node with the type name of the type symbol.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node  The node that should be tested.\r\n     * @param type  The type of the node that should be tested.\r\n     * @returns TRUE when the given node and type look like a type alias, otherwise FALSE.\r\n     */\r\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.Type): boolean {\r\n        if (!type || !node || !node.typeName) {\r\n            return false;\r\n        }\r\n        if (!type.symbol) {\r\n            return true;\r\n        }\r\n\r\n        const checker = context.checker;\r\n        let symbolName = checker.getFullyQualifiedName(type.symbol).split('.');\r\n        if (!symbolName.length) {\r\n            return false;\r\n        }\r\n        if (symbolName[0].substr(0, 1) === '\"') {\r\n            symbolName.shift();\r\n        }\r\n\r\n        let nodeName = _ts.getTextOfNode(node.typeName).split('.');\r\n        if (!nodeName.length) {\r\n            return false;\r\n        }\r\n\r\n        let common = Math.min(symbolName.length, nodeName.length);\r\n        symbolName = symbolName.slice(-common);\r\n        nodeName = nodeName.slice(-common);\r\n\r\n        return nodeName.join('.') !== symbolName.join('.');\r\n    }\r\n\r\n    /**\r\n     * Create a reflection for the given type alias node.\r\n     *\r\n     * This is a node based converter with no type equivalent.\r\n     *\r\n     * Use [[isTypeAlias]] beforehand to test whether a given type/node combination is\r\n     * pointing to a type alias.\r\n     *\r\n     * ```\r\n     * type MyNumber = number;\r\n     * let someValue: MyNumber;\r\n     * ```\r\n     *\r\n     * @param node  The node whose type should be reflected.\r\n     * @returns  A type reference pointing to the type alias definition.\r\n     */\r\n    convertNode(context: Context, node: ts.TypeReferenceNode): ReferenceType {\r\n        const name = _ts.getTextOfNode(node.typeName);\r\n        const result = new ReferenceType(name, ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME);\r\n\r\n        if (node.typeArguments) {\r\n            result.typeArguments = node.typeArguments.map(n => this.owner.convertType(context, n));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]}