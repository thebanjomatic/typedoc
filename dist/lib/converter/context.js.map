{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/lib/converter/context.ts"],"names":[],"mappings":";;AACA,uCAAkD;AAGlD,yCAA2F;AAC3F,6DAAiE;AACjE,yCAAwC;AAKxC;IA6FI,iBAAY,SAAoB,EAAE,SAAmB,EAAE,OAAuB,EAAE,OAAmB;QAd3F,aAAQ,GAAG,CAAC,IAAI,CAAC;QAerB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QAErB,IAAM,OAAO,GAAG,IAAI,yBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACtD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC;QAErB,EAAE,CAAC,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,eAAe,GAAG,IAAI,qBAAS,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;QACpE,CAAC;IACL,CAAC;IAKD,oCAAkB,GAAlB;QACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,CAAC;IACnE,CAAC;IAQD,mCAAiB,GAAjB,UAAkB,IAAa;QAC3B,IAAI,QAAiB,CAAC;QACtB,IAAI,CAAC;YACD,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACpD,CAAC;QAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QACjB,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACZ,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;gBACd,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACjE,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC3C,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACxE,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBACxE,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAC/E,CAAC;QACL,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC;IACpB,CAAC;IAOD,2BAAS,GAAT;QACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,MAAM,CAAC;IAC7C,CAAC;IAWD,6BAAW,GAAX,UAAY,MAAiB;QACzB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACV,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;YACb,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChC,CAAC;QACD,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC;IACrB,CAAC;IAYD,oCAAkB,GAAlB,UAAmB,UAAsB,EAAE,IAAa,EAAE,MAAkB;QACxE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC;QAErD,IAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAC3E,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC3D,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,EAAE,CAAC;QACnD,CAAC;IACL,CAAC;IAWD,yBAAO,GAAP,UAAQ,IAAY,EAAE,UAAsB,EAAE,IAAc;QACxD,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;IACzD,CAAC;IAQD,gCAAc,GAAd,UAAe,IAAmB,EAAE,QAAkB;QAClD,IAAM,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;QAC7C,IAAI,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;QAC9D,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;YAClB,UAAU,GAAG,UAAU,IAAI,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpE,CAAC;QAED,EAAE,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC;YAChD,MAAM,CAAC;QACX,CAAC;QAED,IAAI,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAC3C,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAChB,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,CAAC;YAC3C,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC;YACxD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,mBAAmB,IAAI,KAAK,CAAC,CAAC,CAAC;gBAC/C,MAAM,CAAC;YACX,CAAC;QACL,CAAC;QAED,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QAEnC,IAAI,CAAC,OAAO,CAAC,qBAAS,CAAC,gBAAgB,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAC7D,QAAQ,EAAE,CAAC;QAEX,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;IAC/B,CAAC;IAyBM,2BAAS,GAAhB,UAAiB,KAAiB;QAAE,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,6BAAc;;QAC9C,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC;QACX,CAAC;QACD,IAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC5B,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;QAEhC,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC5B,IAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC;QAC5C,IAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC;QAE9C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;QACjH,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAE1B,QAAQ,EAAE,CAAC;QAEX,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;QACtB,IAAI,CAAC,cAAc,GAAG,iBAAiB,CAAC;QACxC,IAAI,CAAC,aAAa,GAAG,gBAAgB,CAAC;IAC1C,CAAC;IASD,yBAAO,GAAP,UAAQ,QAAiB,EAAE,aAAyC;QAApE,iBAiDC;QAhDG,IAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC;QAClC,IAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC;QACpC,IAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC;QAC5C,IAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC;QAE5C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QAEpB,IAAM,MAAM,GAAyB,IAAI,CAAC,KAAK,CAAC;QAChD,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,YAAY,2BAAmB,CAAC,CAAC,CAAC,CAAC;YAC3C,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;QACrD,CAAC;QAED,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YAClB,IAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtE,MAAM,CAAC,MAAM,CAAC;YAClB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC;gBACtD,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACpC,CAAC;QACL,CAAC;QAED,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,CAAC;QACxD,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACxB,CAAC;QAED,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAChB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,KAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAI,EAAE,CAAC,CAAC,EAAnC,CAAmC,CAAC,CAAC;QACvF,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC9B,CAAC;QAED,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAE3C,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC;QAC5B,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC;QAC9B,IAAI,CAAC,aAAa,GAAG,gBAAgB,CAAC;QACtC,IAAI,CAAC,aAAa,GAAG,gBAAgB,CAAC;QAEtC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YAClB,OAAO,IAAI,CAAC,iBAAiB,CAAC;QAClC,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IASO,uCAAqB,GAA7B,UAA8B,UAAqD,EAAE,QAAkB;QAAvG,iBAsBC;QArBG,IAAM,cAAc,GAAqB,EAAE,CAAC;QAE5C,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACX,GAAG,CAAC,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;gBAClC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC3C,QAAQ,CAAC;gBACb,CAAC;gBACD,cAAc,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;YACnD,CAAC;QACL,CAAC;QAED,UAAU,CAAC,OAAO,CAAC,UAAC,WAAwC,EAAE,KAAa;YACvE,IAAM,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC;YACrC,EAAE,CAAC,CAAC,KAAI,CAAC,aAAa,IAAI,KAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAClD,cAAc,CAAC,IAAI,CAAC,GAAG,KAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YACrD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,cAAc,CAAC,IAAI,CAAC,GAAG,oCAAmB,CAAC,KAAI,EAAE,WAAW,CAAC,CAAC;YAClE,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,cAAc,CAAC;IAC1B,CAAC;IACL,cAAC;AAAD,CAAC,AAjXD,IAiXC;AAjXY,0BAAO","sourcesContent":["import * as ts from 'typescript';\r\nimport { Minimatch, IMinimatch } from 'minimatch';\r\n\r\nimport { Logger } from '../utils/loggers';\r\nimport { Reflection, ProjectReflection, ContainerReflection, Type } from '../models/index';\r\nimport { createTypeParameter } from './factories/type-parameter';\r\nimport { Converter } from './converter';\r\n\r\n/**\r\n * The context describes the current state the converter is in.\r\n */\r\nexport class Context {\r\n    /**\r\n     * The converter instance that has created the context.\r\n     */\r\n    converter: Converter;\r\n\r\n    /**\r\n     * A list of all files that have been passed to the TypeScript compiler.\r\n     */\r\n    fileNames: string[];\r\n\r\n    /**\r\n     * The TypeChecker instance returned by the TypeScript compiler.\r\n     */\r\n    checker: ts.TypeChecker;\r\n\r\n    /**\r\n     * The program that is currently processed.\r\n     */\r\n    program: ts.Program;\r\n\r\n    /**\r\n     * The project that is currently processed.\r\n     */\r\n    project: ProjectReflection;\r\n\r\n    /**\r\n     * The scope or parent reflection that is currently processed.\r\n     */\r\n    scope: Reflection;\r\n\r\n    /**\r\n     * Is the current source file marked as being external?\r\n     */\r\n    isExternal: boolean;\r\n\r\n    /**\r\n     * Is the current source file a declaration file?\r\n     */\r\n    isDeclaration: boolean;\r\n\r\n    /**\r\n     * The currently set type parameters.\r\n     */\r\n    typeParameters: ts.MapLike<Type>;\r\n\r\n    /**\r\n     * The currently set type arguments.\r\n     */\r\n    typeArguments: Type[];\r\n\r\n    /**\r\n     * Is the converter in inheritance mode?\r\n     */\r\n    isInherit: boolean;\r\n\r\n    /**\r\n     * The node that has started the inheritance mode.\r\n     */\r\n    inheritParent: ts.Node;\r\n\r\n    /**\r\n     * List symbol ids of inherited children already visited while inheriting.\r\n     */\r\n    inheritedChildren: number[];\r\n\r\n    /**\r\n     * The names of the children of the scope before inheritance has been started.\r\n     */\r\n    inherited: string[];\r\n\r\n    /**\r\n     * A list of parent nodes that have been passed to the visit function.\r\n     */\r\n    visitStack: ts.Node[];\r\n\r\n    /**\r\n     * Next free symbol id used by [[getSymbolID]].\r\n     */\r\n    private symbolID = -1024;\r\n\r\n    /**\r\n     * The pattern that should be used to flag external source files.\r\n     */\r\n    private externalPattern: IMinimatch;\r\n\r\n    /**\r\n     * Create a new Context instance.\r\n     *\r\n     * @param converter  The converter instance that has created the context.\r\n     * @param fileNames  A list of all files that have been passed to the TypeScript compiler.\r\n     * @param checker  The TypeChecker instance returned by the TypeScript compiler.\r\n     */\r\n    constructor(converter: Converter, fileNames: string[], checker: ts.TypeChecker, program: ts.Program) {\r\n        this.converter = converter;\r\n        this.fileNames = fileNames;\r\n        this.checker = checker;\r\n        this.program = program;\r\n        this.visitStack = [];\r\n\r\n        const project = new ProjectReflection(converter.name);\r\n        this.project = project;\r\n        this.scope = project;\r\n\r\n        if (converter.externalPattern) {\r\n            this.externalPattern = new Minimatch(converter.externalPattern);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the compiler options.\r\n     */\r\n    getCompilerOptions(): ts.CompilerOptions {\r\n        return this.converter.application.options.getCompilerOptions();\r\n    }\r\n\r\n    /**\r\n     * Return the type declaration of the given node.\r\n     *\r\n     * @param node  The TypeScript node whose type should be resolved.\r\n     * @returns The type declaration of the given node.\r\n     */\r\n    getTypeAtLocation(node: ts.Node): ts.Type {\r\n        let nodeType: ts.Type;\r\n        try {\r\n            nodeType = this.checker.getTypeAtLocation(node);\r\n        } catch (error) {\r\n        }\r\n        if (!nodeType) {\r\n            if (node.symbol) {\r\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.symbol);\r\n            } else if (node.parent && node.parent.symbol) {\r\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.parent.symbol);\r\n            } else if (node.parent && node.parent.parent && node.parent.parent.symbol) {\r\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.parent.parent.symbol);\r\n            }\r\n        }\r\n        return nodeType;\r\n    }\r\n\r\n    /**\r\n     * Return the current logger instance.\r\n     *\r\n     * @returns The current logger instance.\r\n     */\r\n    getLogger(): Logger {\r\n        return this.converter.application.logger;\r\n    }\r\n\r\n    /**\r\n     * Return the symbol id of the given symbol.\r\n     *\r\n     * The compiler sometimes does not assign an id to symbols, this method makes sure that we have one.\r\n     * It will assign negative ids if they are not set.\r\n     *\r\n     * @param symbol  The symbol whose id should be returned.\r\n     * @returns The id of the given symbol.\r\n     */\r\n    getSymbolID(symbol: ts.Symbol): number {\r\n        if (!symbol) {\r\n            return null;\r\n        }\r\n        if (!symbol.id) {\r\n            symbol.id = this.symbolID--;\r\n        }\r\n        return symbol.id;\r\n    }\r\n\r\n    /**\r\n     * Register a newly generated reflection.\r\n     *\r\n     * Ensures that the reflection is both listed in [[Project.reflections]] and\r\n     * [[Project.symbolMapping]] if applicable.\r\n     *\r\n     * @param reflection  The reflection that should be registered.\r\n     * @param node  The node the given reflection was resolved from.\r\n     * @param symbol  The symbol the given reflection was resolved from.\r\n     */\r\n    registerReflection(reflection: Reflection, node: ts.Node, symbol?: ts.Symbol) {\r\n        this.project.reflections[reflection.id] = reflection;\r\n\r\n        const id = this.getSymbolID(symbol ? symbol : (node ? node.symbol : null));\r\n        if (!this.isInherit && id && !this.project.symbolMapping[id]) {\r\n            this.project.symbolMapping[id] = reflection.id;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger a node reflection event.\r\n     *\r\n     * All events are dispatched on the current converter instance.\r\n     *\r\n     * @param name  The name of the event that should be triggered.\r\n     * @param reflection  The triggering reflection.\r\n     * @param node  The triggering TypeScript node if available.\r\n     */\r\n    trigger(name: string, reflection: Reflection, node?: ts.Node) {\r\n        this.converter.trigger(name, this, reflection, node);\r\n    }\r\n\r\n    /**\r\n     * Run the given callback with the context configured for the given source file.\r\n     *\r\n     * @param node  The TypeScript node containing the source file declaration.\r\n     * @param callback  The callback that should be executed.\r\n     */\r\n    withSourceFile(node: ts.SourceFile, callback: Function) {\r\n        const externalPattern = this.externalPattern;\r\n        let isExternal = this.fileNames.indexOf(node.fileName) === -1;\r\n        if (externalPattern) {\r\n            isExternal = isExternal || externalPattern.match(node.fileName);\r\n        }\r\n\r\n        if (isExternal && this.converter.excludeExternals) {\r\n            return;\r\n        }\r\n\r\n        let isDeclaration = node.isDeclarationFile;\r\n        if (isDeclaration) {\r\n            const lib = this.converter.getDefaultLib();\r\n            const isLib = node.fileName.substr(-lib.length) === lib;\r\n            if (!this.converter.includeDeclarations || isLib) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.isExternal = isExternal;\r\n        this.isDeclaration = isDeclaration;\r\n\r\n        this.trigger(Converter.EVENT_FILE_BEGIN, this.project, node);\r\n        callback();\r\n\r\n        this.isExternal = false;\r\n        this.isDeclaration = false;\r\n    }\r\n\r\n    /**\r\n     * @param callback  The callback function that should be executed with the changed context.\r\n     */\r\n    public withScope(scope: Reflection, callback: Function): void;\r\n\r\n    /**\r\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\r\n     * @param callback  The callback function that should be executed with the changed context.\r\n     */\r\n    public withScope(scope: Reflection, parameters: ts.NodeArray<ts.TypeParameterDeclaration>, callback: Function): void;\r\n\r\n    /**\r\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\r\n     * @param preserve  Should the currently set type parameters of the context be preserved?\r\n     * @param callback  The callback function that should be executed with the changed context.\r\n     */\r\n    public withScope(scope: Reflection, parameters: ts.NodeArray<ts.TypeParameterDeclaration>, preserve: boolean, callback: Function): void;\r\n\r\n    /**\r\n     * Run the given callback with the scope of the context set to the given reflection.\r\n     *\r\n     * @param scope  The reflection that should be set as the scope of the context while the callback is invoked.\r\n     */\r\n    public withScope(scope: Reflection, ...args: any[]): void {\r\n        if (!scope || !args.length) {\r\n            return;\r\n        }\r\n        const callback = args.pop();\r\n        const parameters = args.shift();\r\n\r\n        const oldScope = this.scope;\r\n        const oldTypeArguments = this.typeArguments;\r\n        const oldTypeParameters = this.typeParameters;\r\n\r\n        this.scope = scope;\r\n        this.typeParameters = parameters ? this.extractTypeParameters(parameters, args.length > 0) : this.typeParameters;\r\n        this.typeArguments = null;\r\n\r\n        callback();\r\n\r\n        this.scope = oldScope;\r\n        this.typeParameters = oldTypeParameters;\r\n        this.typeArguments = oldTypeArguments;\r\n    }\r\n\r\n    /**\r\n     * Inherit the children of the given TypeScript node to the current scope.\r\n     *\r\n     * @param baseNode  The node whose children should be inherited.\r\n     * @param typeArguments  The type arguments that apply while inheriting the given node.\r\n     * @return The resulting reflection / the current scope.\r\n     */\r\n    inherit(baseNode: ts.Node, typeArguments?: ts.NodeArray<ts.TypeNode>): Reflection {\r\n        const wasInherit = this.isInherit;\r\n        const oldInherited = this.inherited;\r\n        const oldInheritParent = this.inheritParent;\r\n        const oldTypeArguments = this.typeArguments;\r\n\r\n        this.isInherit = true;\r\n        this.inheritParent = baseNode;\r\n        this.inherited = [];\r\n\r\n        const target = <ContainerReflection> this.scope;\r\n        if (!(target instanceof ContainerReflection)) {\r\n            throw new Error('Expected container reflection');\r\n        }\r\n\r\n        if (baseNode.symbol) {\r\n            const id = this.getSymbolID(baseNode.symbol);\r\n            if (this.inheritedChildren && this.inheritedChildren.indexOf(id) !== -1) {\r\n                return target;\r\n            } else {\r\n                this.inheritedChildren = this.inheritedChildren || [];\r\n                this.inheritedChildren.push(id);\r\n            }\r\n        }\r\n\r\n        if (target.children) {\r\n            this.inherited = target.children.map((c) => c.name);\r\n        } else {\r\n            this.inherited = [];\r\n        }\r\n\r\n        if (typeArguments) {\r\n            this.typeArguments = typeArguments.map((t) => this.converter.convertType(this, t));\r\n        } else {\r\n            this.typeArguments = null;\r\n        }\r\n\r\n        this.converter.convertNode(this, baseNode);\r\n\r\n        this.isInherit = wasInherit;\r\n        this.inherited = oldInherited;\r\n        this.inheritParent = oldInheritParent;\r\n        this.typeArguments = oldTypeArguments;\r\n\r\n        if (!this.isInherit) {\r\n            delete this.inheritedChildren;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Convert the given list of type parameter declarations into a type mapping.\r\n     *\r\n     * @param parameters  The list of type parameter declarations that should be converted.\r\n     * @param preserve  Should the currently set type parameters of the context be preserved?\r\n     * @returns The resulting type mapping.\r\n     */\r\n    private extractTypeParameters(parameters: ts.NodeArray<ts.TypeParameterDeclaration>, preserve?: boolean): ts.MapLike<Type> {\r\n        const typeParameters: ts.MapLike<Type> = {};\r\n\r\n        if (preserve) {\r\n            for (let key in this.typeParameters) {\r\n                if (!this.typeParameters.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n                typeParameters[key] = this.typeParameters[key];\r\n            }\r\n        }\r\n\r\n        parameters.forEach((declaration: ts.TypeParameterDeclaration, index: number) => {\r\n            const name = declaration.symbol.name;\r\n            if (this.typeArguments && this.typeArguments[index]) {\r\n                typeParameters[name] = this.typeArguments[index];\r\n            } else {\r\n                typeParameters[name] = createTypeParameter(this, declaration);\r\n            }\r\n        });\r\n\r\n        return typeParameters;\r\n    }\r\n}\r\n"]}